/*
 * MoonCangjie ä»“é¢‰å¥”æœˆè®¡åˆ’ ğŸŒ•
 * https://github.com/SunriseSummer/Lua/tree/cangjie-inside-claude-opus4.6
 * æœ¬é¡¹ç›®åœ¨ Lua è¿è¡Œæ—¶ä¸Šå«æ¥ä»“é¢‰ç¼–ç¨‹è¯­è¨€ï¼Œä»¥å®ç°ä»“é¢‰ç¨‹åºçš„è§£é‡Šæ‰§è¡Œ
 * å°†ä»“é¢‰çš„ç°ä»£è¯­è¨€ç‰¹æ€§ä¸ Lua çš„åŠ¨æ€è¿è¡Œæ—¶èƒ½åŠ›èåˆå¢å¼º
 */ 

// å˜é‡ä¸åŸºç¡€æ•°æ®ç±»å‹
let int: Int64 = 2026
var float: Float64 = 3.14
let char: Rune = 'ğŸŒ'
let string: String = "Cangjie"
let tuple: (Int64, String) = (2026, "Cangjie")
let array = Array<Int64>(5, { i: Int64 => i * i + 1 })
println(tuple[1])
println("${char} -> ${ 2025 + 1 }")

// for å¾ªç¯ä¸åŒºé—´è¡¨è¾¾å¼
array[3..5] = [2, 1] // åŒºé—´ç´¢å¼•
for (i in 0..array.size) {
    print("${array[i]} ")
}
println()

// å‡½æ•°ç”¨ä½œå‚æ•°/è¿”å›å€¼/å˜é‡èµ‹å€¼ï¼ŒåµŒå¥—å‡½æ•°ï¼Œé—­åŒ…ï¼Œå‘½åå‚æ•°ï¼Œé»˜è®¤å€¼
func node(value: String,
    left!: () -> Unit = {=>}, right!: () -> Unit = {=>}) {
    return { =>
        left()
        print(value)
        right()
    }
}
let closure = node("A",
    left: node("B", left: node("C", right: node("D"))),
    right: node("E", left: node("F"), right: node("G")))
closure() // è¾“å‡º CDBAFEG
println()

// ç»“æ„ä½“ä¸ç±»ï¼Œè‡ªåŠ¨æ„é€ å‡½æ•°ï¼Œä¸»æ„é€ å‡½æ•°ï¼Œæ“ä½œç¬¦é‡è½½
struct Point {
    var x: Float64 = 0.0
    var y: Float64 = 0.0
    operator func +(that: Point): Point {
        Point(this.x + that.x, this.y + that.y)
    }
}
class Circle {
    Circle(var center: Point, var radius: Float64) {
        if (radius < 1.0) {
            this.radius = 1.0
        }
    }
    func info(): String {
        "${center.x}, ${center.y}, ${radius}"
    }
}
let p = Point(1.0, 1.5) + Point(2.0, 1.0)
let c = Circle(p, 3.14)
println(c.info())

// æšä¸¾ï¼Œä»£æ•°ç‰¹æ€§ï¼Œæ¨¡å¼åŒ¹é…
enum Tree {
    Empty | Leaf(Int64) | Node(Int64, Tree, Tree)

    func traverse(): Unit {
        match (this) {
            case Empty => ()
            case Leaf(value) => print(value)
            case Node(value, left, right) =>
                left.traverse()
                print(value)
                right.traverse()
        }
    }
}
let tree = Node(1,
    Node(2, Node(3, Empty, Leaf(4)), Empty),
    Node(5, Leaf(6), Leaf(7)))
tree.traverse()
println()

// æ¥å£ä¸æ‰©å±•
interface Moveable {
    func move(dx: Float64, dy: Float64): Float64
}
extend Point <: Moveable {
    func move(dx: Float64, dy: Float64): Float64 {
        this.x = this.x + dx
        this.y = this.y + dy
        return (dx ** 2 + dy ** 2) ** 0.5
    }
}
let pt = Point(1.0, 1.0)
let distance = p.move(3.0, 4.0)
println(distance)

extend Int64 {
    func isEven(): Bool {
        this % 2 == 0
    }
}
let num: Int64 = 2026
println(num.isEven())

// Option
let empty: ?Int64 = None
println(empty.getOrDefault({=> 0}))
let valid: ?Int64 = Some(2026)
println(valid.getOrDefault({=> 0}))

// æ¨¡å¼åŒ¹é…
let types = match (pt) {
  case c: Circle => "Circle"
  case p: Point => "Point"
  case _ => "Unknown"
}
println(types)

// if-letï¼Œwhile-letï¼Œæ¨¡å¼åŒ¹é…æ··åˆé€»è¾‘è¿ç®—
if (let Some(value) <- valid) {
    println(value)
}
var count: Int64 = 3
while (let Some(value) <- valid && count > 0) {
    println(count)
    count = count - 1
}

//======== èåˆ Lua å¼•æ“çš„åŠ¨æ€ç‰¹æ€§ ========//
// dynamic table
let dict = {}
dict["name"] = "Cangjie"
dict["version"] = 1
dict[42] = "answer"
for (k, v in pairs(dict)) {
    println("${k} -> ${v}")
}

// multiple return and multiple assignment
func divmod(a: Int64, b: Int64) {
  return a / b, a % b
}
let q, r = divmod(17, 5)
println("${q}, ${r}")

// åŠ¨æ€è§£é‡Šæ‰§è¡Œ
let code = "let f = { x, y => x ** y }; println(f(2, 3))"
let chunk, err = load(code)
let ok, er = pcall(chunk) // print 8.0
println(ok)

