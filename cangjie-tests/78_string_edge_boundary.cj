dofile("cangjie-tests/_testing.cj")

// Test: Additional string edge cases and boundary tests
// Focus: boundary conditions, mixed encodings, comprehensive coverage

// --- Section: Multi-byte boundary indexing ---
// 2-byte: Ã© (U+00E9), Ã± (U+00F1)
// 3-byte: ä½  (U+4F60), â‚¬ (U+20AC)
// 4-byte: ðŸ˜€ (U+1F600), ðŸŽ‰ (U+1F389)
let allWidths = "aÃ©â‚¬ðŸ˜€b"
expectEq(allWidths.size, 5, "mixed-width .size")
expectEq(allWidths[0], r'a', "1-byte char")
expectEq(allWidths[1], r'Ã©', "2-byte char")
expectEq(allWidths[2], r'â‚¬', "3-byte char")
expectEq(allWidths[3], r'ðŸ˜€', "4-byte char")
expectEq(allWidths[4], r'b', "trailing 1-byte char")

// --- Section: Slice boundaries across byte widths ---
expectEq(allWidths[0..1], "a", "slice before 2-byte")
expectEq(allWidths[1..3], "Ã©â‚¬", "slice 2-byte to 3-byte")
expectEq(allWidths[2..=4], "â‚¬ðŸ˜€b", "inclusive slice 3-byte to end")
expectEq(allWidths[0..=4], "aÃ©â‚¬ðŸ˜€b", "full inclusive slice mixed")

// --- Section: String size edge cases ---
expectEq("".size, 0, "empty string size")
expectEq("a".size, 1, "single ASCII size")
expectEq("ä½ ".size, 1, "single 3-byte char size")
expectEq("ðŸ˜€".size, 1, "single 4-byte char size")
expectEq("Ã©".size, 1, "single 2-byte char size")

// --- Section: Slice with equal start/end (empty result) ---
expectEq("hello"[3..3], "", "same start/end slice")
expectEq("ä½ å¥½ä¸–ç•Œ"[2..2], "", "same CJK start/end slice")

// --- Section: Slice at string boundaries ---
expectEq("hello"[0..1], "h", "slice first char")
expectEq("hello"[4..=4], "o", "inclusive slice last char")
expectEq("ä½ å¥½ä¸–ç•Œ"[0..1], "ä½ ", "slice first CJK char")
expectEq("ä½ å¥½ä¸–ç•Œ"[3..=3], "ç•Œ", "inclusive slice last CJK char")

// --- Section: Full-string slice ---
expectEq("hello"[0..=4], "hello", "full inclusive slice ASCII")
expectEq("ä½ å¥½ä¸–ç•Œ"[0..=3], "ä½ å¥½ä¸–ç•Œ", "full inclusive slice CJK")

// --- Section: IndexOf with various byte-width characters ---
let searchStr = "aÃ©â‚¬ðŸ˜€bÃ©"
expectEq(searchStr.indexOf("Ã©"), 1, "indexOf 2-byte char")
expectEq(searchStr.indexOf("â‚¬"), 2, "indexOf 3-byte char")
expectEq(searchStr.indexOf("ðŸ˜€"), 3, "indexOf 4-byte char")
expectEq(searchStr.indexOf("b"), 4, "indexOf after 4-byte char")
expectEq(searchStr.indexOf("Ã©", 2), 5, "indexOf 2-byte char with fromIndex")

// --- Section: LastIndexOf with multi-byte ---
expectEq(searchStr.lastIndexOf("Ã©"), 5, "lastIndexOf 2-byte char")
expectEq(searchStr.lastIndexOf("a"), 0, "lastIndexOf first char")
expectEq(searchStr.lastIndexOf("x"), -1, "lastIndexOf not found")

// --- Section: Contains with multi-byte substrings ---
expectTrue("Helloä½ å¥½World".contains("ä½ å¥½"), "contains multi-byte substring")
expectTrue("Helloä½ å¥½World".contains("ä½ å¥½Wo"), "contains cross-boundary substring")
expectFalse("Hello".contains("ä½ "), "not contains multi-byte in ASCII")

// --- Section: Replace with byte-width transitions ---
expectEq("aâ‚¬b".replace("â‚¬", "X"), "aXb", "replace 3-byte with 1-byte")
expectEq("aXb".replace("X", "â‚¬"), "aâ‚¬b", "replace 1-byte with 3-byte")
expectEq("ðŸ˜€ðŸ˜€".replace("ðŸ˜€", "!"), "!!", "replace 4-byte with 1-byte")

// --- Section: Split with multi-byte separator ---
let splitResult = "Aä½ Bä½ C".split("ä½ ")
expectEq(splitResult.size, 3, "split by 3-byte sep size")
expectEq(splitResult[0], "A", "split by CJK sep [0]")
expectEq(splitResult[1], "B", "split by CJK sep [1]")
expectEq(splitResult[2], "C", "split by CJK sep [2]")

// --- Section: Split into chars for multi-byte ---
let splitChars = "aÃ©â‚¬".split("")
expectEq(splitChars.size, 3, "split multi-byte into chars size")
expectEq(splitChars[0], "a", "split multi-byte char 0")
expectEq(splitChars[1], "Ã©", "split multi-byte char 1")
expectEq(splitChars[2], "â‚¬", "split multi-byte char 2")

// --- Section: Trim with adjacent multi-byte ---
expectEq("  ä½ å¥½  ".trim(), "ä½ å¥½", "trim spaces around CJK")
expectEq("\t\nðŸ˜€\n\t".trim(), "ðŸ˜€", "trim whitespace around emoji")

// --- Section: StartsWith and EndsWith with multi-byte ---
expectTrue("ðŸ˜€hello".startsWith("ðŸ˜€"), "startsWith emoji")
expectTrue("helloðŸ˜€".endsWith("ðŸ˜€"), "endsWith emoji")
expectFalse("helloðŸ˜€".startsWith("ðŸ˜€"), "not startsWith wrong emoji pos")
expectTrue("cafÃ©".startsWith("caf"), "startsWith partial multi-byte")
expectTrue("cafÃ©".endsWith("fÃ©"), "endsWith multi-byte suffix")

// --- Section: ToRuneArray for mixed byte widths ---
let runes = "aÃ©â‚¬ðŸ˜€".toRuneArray()
expectEq(runes.size, 4, "toRuneArray mixed size")
expectEq(runes[0], r'a', "toRuneArray 1-byte")
expectEq(runes[1], r'Ã©', "toRuneArray 2-byte")
expectEq(runes[2], r'â‚¬', "toRuneArray 3-byte")
expectEq(runes[3], r'ðŸ˜€', "toRuneArray 4-byte")

// --- Section: Concatenation preserves UTF-8 ---
let c1 = "Hello" + "ä½ å¥½"
let c2 = "Helloä½ å¥½"
expectEq(c1, c2, "concat equals direct")
expectEq(c1.size, 7, "concat size")
expectEq(c1[5], r'ä½ ', "concat index into CJK")

// --- Section: String interpolation with multi-byte ---
let name = "cafÃ©"
let msg = "I love ${name}!"
expectEq(msg.size, 12, "interpolation multi-byte size")
expectEq(msg[7], r'c', "interpolation index 7")
expectEq(msg[10], r'Ã©', "interpolation index 10 (2-byte)")

// --- Section: Count with multi-byte ---
expectEq("ä½ å¥½ä½ å¥½ä½ ".count("ä½ "), 3, "count 3-byte char")
expectEq("ðŸ˜€xðŸ˜€yðŸ˜€".count("ðŸ˜€"), 3, "count 4-byte char")
expectEq("abc".count(""), 4, "count empty in ASCII (n+1)")
expectEq("ä½ å¥½".count(""), 3, "count empty in CJK (n+1)")

// --- Section: toAsciiUpper/Lower with mixed content ---
expectEq("Helloä½ å¥½".toAsciiUpper(), "HELLOä½ å¥½", "upper with CJK preserved")
expectEq("Helloä½ å¥½".toAsciiLower(), "helloä½ å¥½", "lower with CJK preserved")

if (!__test_failed) {
    println("PASS: 78_string_edge_boundary")
}
